import {TestBed} from '@angular/core/testing';
import {describe, beforeEach, it, expect, vi} from 'vitest';

import {ExportService} from './export.service';
import {CollectionEntry} from '../domain/entities/CollectionEntry';

describe('ExportService', () => {
  let service: ExportService;

  const createMockGame = (overrides: Partial<CollectionEntry> = {}): CollectionEntry => ({
    id: 'game-1',
    name: 'Test Game',
    rating: 80,
    thumbnailUrl: 'https://example.com/thumb.jpg',
    markedAsPlayed: false,
    markedAsHidden: false,
    markedForLater: false,
    storeLinks: {
      steamLink: null,
      gogLink: null,
      metacriticLink: null,
    },
    ...overrides,
  });

  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [ExportService],
    });

    service = TestBed.inject(ExportService);
  });

  describe('generateMarkdown()', () => {
    it('should include auto-generated header', () => {
      const games: CollectionEntry[] = [];

      const result = service.generateMarkdown(games);

      expect(result).toContain('> This file is automatically generated. Do not edit manually.');
    });

    it('should include Games section header', () => {
      const games: CollectionEntry[] = [];

      const result = service.generateMarkdown(games);

      expect(result).toContain('# Games');
    });

    it('should format unplayed game with empty checkbox', () => {
      const games: CollectionEntry[] = [
        createMockGame({name: 'Unplayed Game', markedAsPlayed: false}),
      ];

      const result = service.generateMarkdown(games);

      expect(result).toContain('- [ ] [[Unplayed Game]]');
    });

    it('should format played game with checked checkbox', () => {
      const games: CollectionEntry[] = [
        createMockGame({name: 'Played Game', markedAsPlayed: true}),
      ];

      const result = service.generateMarkdown(games);

      expect(result).toContain('- [x] [[Played Game]]');
    });

    it('should sort games by rating descending', () => {
      const games: CollectionEntry[] = [
        createMockGame({id: '1', name: 'Low Rated', rating: 50}),
        createMockGame({id: '2', name: 'High Rated', rating: 90}),
        createMockGame({id: '3', name: 'Medium Rated', rating: 70}),
      ];

      const result = service.generateMarkdown(games);

      const lines = result.split('\n');
      const gameLines = lines.filter(line => line.startsWith('- ['));

      expect(gameLines[0]).toContain('High Rated');
      expect(gameLines[1]).toContain('Medium Rated');
      expect(gameLines[2]).toContain('Low Rated');
    });

    it('should sort games alphabetically when ratings are equal', () => {
      const games: CollectionEntry[] = [
        createMockGame({id: '1', name: 'Zelda', rating: 80}),
        createMockGame({id: '2', name: 'Alpha', rating: 80}),
        createMockGame({id: '3', name: 'Mario', rating: 80}),
      ];

      const result = service.generateMarkdown(games);

      const lines = result.split('\n');
      const gameLines = lines.filter(line => line.startsWith('- ['));

      expect(gameLines[0]).toContain('Alpha');
      expect(gameLines[1]).toContain('Mario');
      expect(gameLines[2]).toContain('Zelda');
    });

    it('should separate backlog games into their own section', () => {
      const games: CollectionEntry[] = [
        createMockGame({id: '1', name: 'Regular Game', markedForLater: false}),
        createMockGame({id: '2', name: 'Backlog Game', markedForLater: true}),
      ];

      const result = service.generateMarkdown(games);

      expect(result).toContain('# Games');
      expect(result).toContain('# Backlog');

      const gamesSection = result.split('# Backlog')[0];
      const backlogSection = result.split('# Backlog')[1];

      expect(gamesSection).toContain('Regular Game');
      expect(gamesSection).not.toContain('Backlog Game');
      expect(backlogSection).toContain('Backlog Game');
      expect(backlogSection).not.toContain('Regular Game');
    });

    it('should not include backlog section when no backlog games', () => {
      const games: CollectionEntry[] = [
        createMockGame({name: 'Regular Game', markedForLater: false}),
      ];

      const result = service.generateMarkdown(games);

      expect(result).toContain('# Games');
      expect(result).not.toContain('# Backlog');
    });

    it('should sort backlog games by rating then name', () => {
      const games: CollectionEntry[] = [
        createMockGame({id: '1', name: 'Backlog Low', rating: 50, markedForLater: true}),
        createMockGame({id: '2', name: 'Backlog High', rating: 90, markedForLater: true}),
      ];

      const result = service.generateMarkdown(games);

      const backlogSection = result.split('# Backlog')[1];
      const lines = backlogSection.split('\n').filter(line => line.startsWith('- ['));

      expect(lines[0]).toContain('Backlog High');
      expect(lines[1]).toContain('Backlog Low');
    });

    it('should handle games with special characters in names', () => {
      const games: CollectionEntry[] = [
        createMockGame({name: 'Game: The Sequel (2024)'}),
      ];

      const result = service.generateMarkdown(games);

      expect(result).toContain('- [ ] [[Game: The Sequel (2024)]]');
    });

    it('should end with a newline', () => {
      const games: CollectionEntry[] = [
        createMockGame({name: 'Test Game'}),
      ];

      const result = service.generateMarkdown(games);

      expect(result.endsWith('\n')).toBe(true);
    });
  });

  describe('exportToMarkdown()', () => {
    it('should create and click a download link', () => {
      const games: CollectionEntry[] = [
        createMockGame({name: 'Test Game'}),
      ];

      const createElementSpy = vi.spyOn(document, 'createElement');
      const appendChildSpy = vi.spyOn(document.body, 'appendChild').mockImplementation(() => null as any);
      const removeChildSpy = vi.spyOn(document.body, 'removeChild').mockImplementation(() => null as any);

      const mockLink = {
        href: '',
        download: '',
        click: vi.fn(),
      };
      createElementSpy.mockReturnValue(mockLink as any);

      const createObjectURLSpy = vi.spyOn(URL, 'createObjectURL').mockReturnValue('blob:test');
      const revokeObjectURLSpy = vi.spyOn(URL, 'revokeObjectURL').mockImplementation(() => {});

      service.exportToMarkdown(games);

      expect(createElementSpy).toHaveBeenCalledWith('a');
      expect(mockLink.download).toBe('games.md');
      expect(mockLink.click).toHaveBeenCalled();
      expect(appendChildSpy).toHaveBeenCalled();
      expect(removeChildSpy).toHaveBeenCalled();
      expect(revokeObjectURLSpy).toHaveBeenCalledWith('blob:test');

      createElementSpy.mockRestore();
      appendChildSpy.mockRestore();
      removeChildSpy.mockRestore();
      createObjectURLSpy.mockRestore();
      revokeObjectURLSpy.mockRestore();
    });
  });
});
